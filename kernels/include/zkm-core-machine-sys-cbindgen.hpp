#pragma once

/* Automatically generated by `cbindgen`. Not intended for manual editing. */

#include <cstdint>

namespace zkm_core_machine_sys {

/// The number of bits in a byte.
constexpr static const uintptr_t BYTE_SIZE = 8;

/// The number of different byte operations.
constexpr static const uintptr_t NUM_BYTE_OPS = 10;

constexpr static const uintptr_t NUM_ROWS = (1 << 16);

/// The maximum log degree of the CPU chip to avoid lookup multiplicity overflow.
constexpr static const uintptr_t MAX_CPU_LOG_DEGREE = 22;

constexpr static const uintptr_t GLOBAL_INITIAL_DIGEST_POS_COPY = 377;

constexpr static const uintptr_t NUM_LOCAL_MEMORY_ENTRIES_PER_ROW = 4;

/// The maximum log number of shards in core.
constexpr static const uintptr_t MAX_LOG_NUMBER_OF_SHARDS = 16;

/// The maximum number of shards in core.
constexpr static const uintptr_t MAX_NUMBER_OF_SHARDS = (1 << MAX_LOG_NUMBER_OF_SHARDS);

/// The width of the permutation.
constexpr static const uintptr_t WIDTH = 16;

/// The rate of the permutation.
constexpr static const uintptr_t RATE = (WIDTH / 2);

/// The number of external rounds.
constexpr static const uintptr_t NUM_EXTERNAL_ROUNDS = 8;

/// The number of internal rounds.
constexpr static const uintptr_t NUM_INTERNAL_ROUNDS = 13;

/// The total number of rounds.
constexpr static const uintptr_t NUM_ROUNDS = (NUM_EXTERNAL_ROUNDS + NUM_INTERNAL_ROUNDS);

constexpr static const uintptr_t GHOST = (NUM_INTERNAL_ROUNDS - 1);

constexpr static const uintptr_t KECCAK_GENERAL_RATE_U32S = 36;

constexpr static const uintptr_t KECCAK_STATE_U32S = 50;

constexpr static const uintptr_t KECCAK_GENERAL_OUTPUT_U32S = 16;

/// The maximum size of the memory in bytes.
constexpr static const uint32_t MAXIMUM_MEMORY_SIZE = UINT32_MAX;

/// The size of a word in bytes.
constexpr static const uintptr_t WORD_SIZE = 4;

/// The file descriptor for stdout.
constexpr static const uint32_t FD_STDOUT = 1;

/// The file descriptor for stderr.
constexpr static const uint32_t FD_STDERR = 2;

/// The minimum file descriptor.
///
/// Any file descriptor must be greater than this value, otherwise the executor will panic.
///
/// This is useful for deprecating file descriptors.
constexpr static const uint32_t LOWEST_ALLOWED_FD = 10;

/// The default increment for the program counter.  Is used for all instructions except
/// for branches and jumps.
constexpr static const uint32_t DEFAULT_PC_INC = 4;

/// This is used in the `InstrEvent` to indicate that the instruction is not from the CPU.
/// A valid pc should be divisible by 4, so we use 1 to indicate that the pc is not used.
constexpr static const uint32_t UNUSED_PC = 1;

/// The number of 32 bit words in the Ziren proof's committed value digest.
constexpr static const uintptr_t PV_DIGEST_NUM_WORDS = 8;

/// The number of field elements in the poseidon2 digest.
constexpr static const uintptr_t POSEIDON_NUM_WORDS = 8;

constexpr static const uintptr_t DIGEST_SIZE = 8;

/// The threshold for splitting deferred events.
constexpr static const uintptr_t MAX_DEFERRED_SPLIT_THRESHOLD = (1 << 15);

/// The maximum number of elements that can be stored in the public values vec.  Both Ziren and
/// recursive proofs need to pad their public values vec to this length.  This is required since the
/// recursion verification program expects the public values vec to be fixed length.
constexpr static const uintptr_t PROOF_MAX_NUM_PVS = 231;

/// An opcode (short for "operation code") specifies the operation to be performed by the processor.
enum class Opcode : uint8_t {
  ADD = 0,
  SUB = 1,
  MULT = 2,
  MULTU = 3,
  MUL = 4,
  DIV = 5,
  DIVU = 6,
  SLL = 7,
  SRL = 8,
  SRA = 9,
  ROR = 10,
  SLT = 11,
  SLTU = 12,
  AND = 13,
  OR = 14,
  XOR = 15,
  NOR = 16,
  CLZ = 17,
  CLO = 18,
  BEQ = 19,
  BGEZ = 20,
  BGTZ = 21,
  BLEZ = 22,
  BLTZ = 23,
  BNE = 24,
  Jump = 25,
  Jumpi = 26,
  JumpDirect = 27,
  LB = 28,
  LBU = 29,
  LH = 30,
  LHU = 31,
  LW = 32,
  LWL = 33,
  LWR = 34,
  LL = 35,
  SB = 36,
  SH = 37,
  SW = 38,
  SWL = 39,
  SWR = 40,
  SC = 41,
  SYSCALL = 42,
  MEQ = 43,
  MNE = 44,
  TEQ = 45,
  SEXT = 46,
  WSBH = 47,
  EXT = 48,
  MADDU = 49,
  MSUBU = 50,
  INS = 51,
  MOD = 52,
  MODU = 53,
  UNIMPL = 255,
};

struct KoalaBearParameters;

/// Arithmetic Logic Unit (ALU) Event.
///
/// This object encapsulated the information needed to prove an ALU operation. This includes its
/// shard, opcode, operands, and other relevant information.
struct AluEvent {
  uint32_t pc;
  uint32_t next_pc;
  /// The opcode.
  Opcode opcode;
  /// The upper bits of the output operand.
  /// This is used for the MULT, MULTU, DIV and DIVU opcodes.
  uint32_t hi;
  /// The output operand.
  uint32_t a;
  /// The first input operand.
  uint32_t b;
  /// The second input operand.
  uint32_t c;
};

template<typename MP>
using MontyField31 = uint32_t;

/// The prime field `2^31 - 2^24 + 1`, a.k.a. the Koala Bear field.
using KoalaBearP3 = MontyField31<KoalaBearParameters>;

/// An array of four bytes to represent a 32-bit value.
///
/// We use the generic type `T` to represent the different representations of a byte, ranging from
/// a `u8` to a `AB::Var` or `AB::Expr`.
template<typename T>
struct Word {
  T _0[WORD_SIZE];
};

/// A set of columns needed to compute the add of two words.
template<typename T>
struct AddOperation {
  /// The result of `a + b`.
  Word<T> value;
  /// Trace.
  T carry[3];
};

/// The column layout for the chip.
template<typename T>
struct AddSubCols {
  /// The current/next pc, used for instruction lookup table.
  T pc;
  T next_pc;
  /// Instance of `AddOperation` to handle addition logic in `AddSubChip`'s ALU operations.
  /// It's result will be `a` for the add operation and `b` for the sub operation.
  AddOperation<T> add_operation;
  /// The first input operand.  This will be `b` for add operations and `a` for sub operations.
  Word<T> operand_1;
  /// The second input operand.  This will be `c` for both operations.
  Word<T> operand_2;
  /// Flag indicating whether the opcode is `ADD`.
  T is_add;
  /// Flag indicating whether the opcode is `SUB`.
  T is_sub;
};

/// The column layout for instructions.
template<typename T>
struct InstructionCols {
  /// The opcode for this cycle.
  T opcode;
  /// The first operand for this instruction.
  T op_a;
  /// The second operand for this instruction.
  Word<T> op_b;
  /// The third operand for this instruction.
  Word<T> op_c;
  /// Flags to indicate if op_a is register 0.
  T op_a_0;
  /// Whether op_b is an immediate value.
  T imm_b;
  /// Whether op_c is an immediate value.
  T imm_c;
};

template<typename T>
struct MemoryAccessCols {
  /// The value of the memory access.
  Word<T> value;
  /// The previous shard and timestamp that this memory access is being read from.
  T prev_shard;
  T prev_clk;
  /// This will be true if the current shard == prev_access's shard, else false.
  T compare_clk;
  /// The following columns are decomposed limbs for the difference between the current access's
  /// timestamp and the previous access's timestamp.  Note the actual value of the timestamp
  /// is either the accesses' shard or clk depending on the value of compare_clk.
  /// This column is the least significant 16 bit limb of current access timestamp - prev access
  /// timestamp.
  T diff_16bit_limb;
  /// This column is the most significant 8 bit limb of current access timestamp - prev access
  /// timestamp.
  T diff_8bit_limb;
};

/// Memory read-write access.
template<typename T>
struct MemoryReadWriteCols {
  Word<T> prev_value;
  MemoryAccessCols<T> access;
};

/// Memory read access.
template<typename T>
struct MemoryReadCols {
  MemoryAccessCols<T> access;
};

/// The column layout for the CPU.
template<typename T>
struct CpuCols {
  /// The current shard.
  T shard;
  /// The least significant 16 bit limb of clk.
  T clk_16bit_limb;
  /// The most significant 8 bit limb of clk.
  T clk_8bit_limb;
  /// The shard to send to the opcode specific tables.  This should be 0 for all instructions other
  /// than the syscall and memory instructions.
  T shard_to_send;
  /// The clk to send to the opcode specific tables.  This should be 0 for all instructions other
  /// than the syscall and memory instructions.
  T clk_to_send;
  /// The program counter value.
  T pc;
  /// The next program counter value.
  T next_pc;
  /// The expected next_next program counter value.
  T next_next_pc;
  /// Columns related to the instruction.
  InstructionCols<T> instruction;
  /// The number of extra cycles to add to the clk for a syscall instruction.
  T num_extra_cycles;
  /// Whether this is a memory instruction.
  T is_memory;
  /// Whether the instruction will read and write a register.
  T is_rw_a;
  /// Whether the instruction will write (not read) HI register.
  T is_write_hi;
  /// Whether this is a halt instruction.
  T is_halt;
  /// Whether this is a sequential instruction (not branch or jump or halt).
  T is_sequential;
  /// Operand values, either from registers or immediate values.
  Word<T> op_a_value;
  Word<T> hi_or_prev_a;
  MemoryReadWriteCols<T> op_a_access;
  MemoryReadCols<T> op_b_access;
  MemoryReadCols<T> op_c_access;
  /// Selector to label whether this row is a non padded row.
  T is_real;
  /// Whether op_a is immutable
  T op_a_immutable;
};

/// A column layout for the intermediate states of a Poseidon2 AIR across all rounds.
template<typename T>
struct Poseidon2StateCols {
  T external_rounds_state[NUM_EXTERNAL_ROUNDS][WIDTH];
  T internal_rounds_state[WIDTH];
  T internal_rounds_s0[GHOST];
  T output_state[WIDTH];
};

/// A column layout for the intermediate S-box states of a Poseidon2 AIR across all rounds.
template<typename T>
struct Poseidon2SBoxCols {
  T external_rounds_sbox_state[NUM_EXTERNAL_ROUNDS][WIDTH];
  T internal_rounds_sbox_state[NUM_INTERNAL_ROUNDS];
};

/// A column layout for a poseidon2 permutation with degree 3 constraints.
template<typename T>
struct Poseidon2Degree3Cols {
  Poseidon2StateCols<T> state;
  Poseidon2SBoxCols<T> sbox_state;
};

/// A column layout for a poseidon2 permutation with degree 9 constraints.
template<typename T>
struct Poseidon2Degree9Cols {
  Poseidon2StateCols<T> state;
};

struct Ghost {
  uintptr_t v[GLOBAL_INITIAL_DIGEST_POS_COPY];
};
}  // namespace zkm_core_machine_sys
